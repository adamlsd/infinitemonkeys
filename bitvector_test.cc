/*-
 * Copyright (c) 2015   ADAM David Alan Martin
 *	Infinite Monkeys Fun Project, All Rights Reserved.
 *
 * This file is dually licenced, and may be used by the recipient under the
 * terms of either the Boost Software License, or the 3-Clause BSD License.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * 3-Clause BSD License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "bitvector.h"
#include <fstream>


/**
 * @file
 * @brief Test driver for `InfiniteMonkeys::Bits::bitvector`.
 *
 * # Test Plan:
 *
 * ## Concerns:
 *
 *  * I want to make sure that the `bitvector` can be serialized from non-word-length bit patterns.
 *
 *  * I want to make sure that contents in a `bitvector` are unaltered by other operations on the
 *    vector.
 *
 *  * I want to make sure that operations which change the size of a `bitvector` have the new
 *    size value properly reflected.
 *
 *  * I want to make sure that a `bitvector`'s iterator works correctly for copy and other
 *    operations.
 *
 *   * I want to make sure that a `bitvector`'s conversion function to `std::vector< bool >`
 *     functions as expected.
 *
 *
 * ## Basic Plan:
 *
 *  * Create a `bitvector`, and populate it with a reproducible bit string.
 *  * Check it for correctness, after population.
 *  * Serialize the `bitvector` out to a file.
 *  * Reload the `bitvector` from the file.
 *  * Confirm the rehydrated `bitvector`
 *  * Convert to a `std::vector< bool >` and verify that the sequence is the same.
 *
 */

int
main()
{
	// We want a number which is not a multiple of `sizeof( unsigned )`, to help test the streaming
	// functionality
	const std::size_t N_PASSES= 231;

	// We use a modulus to give us a simple `f( i )` for our test passes.  A simple `i % k` where
	// `k` is both relatively prime to the number of bits in a word, and is smaller than that
	// number of bits gives good bit-pattern coverage to help isolate edge cases
	const int modulus= 3;

	InfiniteMonkeys::Bits::bitvector v;

	assert( v.empty() );
	assert( !v.size() );

	for( int i= 0; i < N_PASSES; ++i )
	{
		assert( v.size() == i );
		v.push_back( i % modulus );
		assert( v.size() == i + 1 );
		assert( v[ i ] == bool( i % modulus ) );
	}
	assert( v.size() == N_PASSES );
	assert( !v.empty() );

	const auto &vr= v;
	for( int i= 0; i < N_PASSES; ++i )
	{
		assert( vr[ i ] == bool( i % modulus ) );
	}

	for( int i= 0; i < N_PASSES; ++i )
	{
		assert( v[ i ] == bool( i % modulus ) );
	}

	{
		std::ofstream outfile( "raw.data" );
		outfile << v;
	}

	{
		std::ifstream infile( "raw.data" );

		const InfiniteMonkeys::Bits::bitvector &v1= v;
		InfiniteMonkeys::Bits::bitvector v2;
		infile >> v2;

		assert( v1.size() == v2.size() );

		for( std::size_t i= 0; i < v2.size(); ++i )
		{
			assert( v1[ i ] == v2[ i ] ); 
		}

		assert( v1 == v2 );


		std::cout << "I see v2 as having " << v2.size() << " elements" << std::endl;
	}

	{
		const std::vector< bool > vb= convert_to_vector_bool( v );
		using std::begin; using std::end;
		assert( v.size() == vb.size() );
		assert( std::equal( begin( v ), end( v ), begin( vb ) ) );
	}

	return 0;
}
	
